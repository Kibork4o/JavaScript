findMirrorWords('There is a man, his name was Bob.');
//функция, която отговаря за върнатите оформени резултати на думите от стринга, подаден, като параметър
function findMirrorWords(string){
    //първо разцепваме целият стринг на съответните думи, от които е сглобен, като изполозваме ' ', като разделител
    var mirrorArr=string.split(' ');
    //създаваме си празен масив, в който ще събираме върнатите резултати, и накрая ще върнем него самият, като краен резултат
    var arrFromMirrors=[];
    //за индекс на масива, който създаваме, ще полозваме "counter", защото при цикъла по - долу,
    // някой от резултаите, при неговото изпълнение, няма да са ни необходими, съответно нямаме нужда от
    //индекси, без стойност
    var counter=0;
    //за край на цикъла ползваме броя на думите, подадени в стринга, който ни е параметър
    for(var i=0; i<mirrorArr.length; i++){
        //функция, "popComma", се грижи, за оформянето на думите (премахването на запетаи, точки и всякакви символи, понктуационни знаци и т.н.)
        //в случая резултатите от функцията "popComma", съхраняваме в променливата "isEmpty", за по лесното й използване.
        var isEmpty=popComma(mirrorArr[i].toLowerCase(), pattern());
        //тук идва ролята на "counter", от о - горе. Ако върнатата стойност от "popComma" е "undefined", ние нямаме нужда от тази стойност
        //съответно нямаме нужда от ключ без стойност
        if(isEmpty!=undefined) {
            //в случаите, когато имаме стойност, зареждаме масива ни
            arrFromMirrors[counter] = isEmpty;
            //и инкрементираме "counter" е 1ца.
            counter+=1;
        }
    }
    //накрая извеждаме резултата
    console.log(arrFromMirrors.join(', '));
}
//"popComma", приема 2 параметъра. 1вият е думата, която ще оформяме, а вторият азбуката,
// с чиито символи сравняваме последният символ от думата, за да видим дали е (точка, запетая, ...)
function popComma(word, pattern){
    //булева стойност, която ни помага, да решим, дали да изтрием последният символ от думата
    var commaHunter=true;
    //цикъма, който създаваме е дълъг, колкото англииската азбук, за да можем да обходим, всичко,
    //което ще сравняваме
    for(var j=0; j<26; j++){
        //сравняваме посдният символ, дали е различен от всяка една буква
        if(word[word.length-1]!=pattern[j]){
            commaHunter=false;
        }
        //ако намерим съвпадение в азбуката излизаме от цикъла без да режем думата
        else{
            commaHunter=true;
            break;
        }
    }
    //ако цикъла се извърти до край и булевата ни стойност е "false", режем послядният символ от думата
    if(commaHunter==false){
        word=word.substr(0, word.length-1);
    }
    //рязали, нерязали връщаме, каквото имаме
    return checkMirrors(word, word.length-1);
}
//функция, съдържаща английската азбука, тук няма какво да обяснявам
function pattern(){
    var alphabetic=['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
    return alphabetic;
}
//функция, проверяваща, за огледалните думи, които търсим
//приема 2 параметъра, единия е върнатата дума, след форматиране от "popComma",
//вторият е дължината на самата дума (която можех така или ина4е да присвоя и вътре в функията, просто тук така реших.)
//самат функция, работи единствено ако са налични използваните в нея функции
function checkMirrors(isMirror, length){
    if(length==0){
        return isMirror;
    }
    if(length==1){
        return twoChars(isMirror);
    }
    if(length==2){
        return tribleCharWords(isMirror);
    }
    if(length%2==0){
        return whenEvenLength(isMirror, length);
    }
    if(length%2!=0){
        return whenOddLength(isMirror, length);
    }
}
//функция, роверяваща, дали дума по дълга от 3 символа и с четна дължина (четна дължина - нечетен брой символи на думата!) е огледална.
//приема 2 параметъра (checkMirrors придава 2та свои параметъра на "whenEvenLength").
function whenEvenLength(isMirror, length){
    //роменливата "half", създаваме, като разделим цялата дължина на 2, след което извадим единица, защото
    //при четна дължина/нечетен брой символи на думата ни интересува дали всички символи, без този по средата са огледални едни на други.
    //например иамема думата "abfba": [0]->a, [1]->b, [2]->f, [3]->b, [4]->a - интересува ни дали [0]=[4] и [1]=[3],
    //като в това време [2], може да бъде коя да е буква от азбуката
    //да се върнем пак на "half", в примера с нечетните символи и четна дължина дължината е 4, като я рязделим на 2, получаваме 2
    //от 2 изваждайки 1, получаваме 1, точно това му трябва на цикъла в случая, защото той трябва да сравни елементите:
    //0 и length-0, както и 1 и length-1
    var half=(length/2)-1;
    for(var i=0; i<half; i++) {
        if (isMirror[i] == isMirror[length - i]) {
            //ако всички тестове са преминати връщаме резултата
            return isMirror;
        }
    }
}
//тук логиката е същата: търсим думи по големи от символа с нечетна дулжина и четен брой на символите.
//тук разликите са че ни интрересуват всички символи в думата. А променливата "half", оформяме,
//като първо извадим единица от цялостната дължина, защото тя в случая е нечетна, а не искаме да делим
//нечетна дума на 2, коато искаме целочислен резултат. Сравняваме символите посъщата логика, като не
//пропускаме нито един от тях.
function whenOddLength(isMirror, length){
    var half=(length-1)/2;
    for(var i=0; i<half; i++) {
        if (isMirror[i] == isMirror[length - i]) {
            //ако всички тестове са преминати връщаме резултата
            return isMirror;
        }
    }
}
//при трисимволна дума отново не ни интересува символа намиращ се по средата.
//тук ръчно сравняваме 1вият и последният (нулев и 2ри) символи дали са еднакви
function tribleCharWords(isMirror){
    if(isMirror[0]==isMirror[2]){
        //и ако са еднакви връщаме резултата
        return isMirror;
    }
}
//ако думата е 2символна. Отново ръчно сравняваме нулевата и първата бъква
function twoChars(isMirror){
    if(isMirror[0]==isMirror[1]){
        //ако са еднакви връщаме резултат
        return isMirror;
    }
}